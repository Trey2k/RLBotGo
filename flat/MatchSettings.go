// automatically generated by the FlatBuffers compiler, do not modify

package flat

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type MatchSettings struct {
	_tab flatbuffers.Table
}

func GetRootAsMatchSettings(buf []byte, offset flatbuffers.UOffsetT) *MatchSettings {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MatchSettings{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *MatchSettings) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MatchSettings) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MatchSettings) PlayerConfigurations(obj *PlayerConfiguration, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *MatchSettings) PlayerConfigurationsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *MatchSettings) GameMode() int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MatchSettings) MutateGameMode(n int8) bool {
	return rcv._tab.MutateInt8Slot(6, n)
}

func (rcv *MatchSettings) GameMap() int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MatchSettings) MutateGameMap(n int8) bool {
	return rcv._tab.MutateInt8Slot(8, n)
}

func (rcv *MatchSettings) SkipReplays() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MatchSettings) MutateSkipReplays(n byte) bool {
	return rcv._tab.MutateByteSlot(10, n)
}

func (rcv *MatchSettings) InstantStart() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MatchSettings) MutateInstantStart(n byte) bool {
	return rcv._tab.MutateByteSlot(12, n)
}

func (rcv *MatchSettings) MutatorSettings(obj *MutatorSettings) *MutatorSettings {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MutatorSettings)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *MatchSettings) ExistingMatchBehavior() int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MatchSettings) MutateExistingMatchBehavior(n int8) bool {
	return rcv._tab.MutateInt8Slot(16, n)
}

func (rcv *MatchSettings) EnableLockstep() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MatchSettings) MutateEnableLockstep(n byte) bool {
	return rcv._tab.MutateByteSlot(18, n)
}

func (rcv *MatchSettings) EnableRendering() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MatchSettings) MutateEnableRendering(n byte) bool {
	return rcv._tab.MutateByteSlot(20, n)
}

func (rcv *MatchSettings) EnableStateSetting() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MatchSettings) MutateEnableStateSetting(n byte) bool {
	return rcv._tab.MutateByteSlot(22, n)
}

func (rcv *MatchSettings) AutoSaveReplay() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MatchSettings) MutateAutoSaveReplay(n byte) bool {
	return rcv._tab.MutateByteSlot(24, n)
}

/// The name of a upk file, like UtopiaStadium_P, which should be loaded.
/// If specified, this overrides gameMap. On Steam version of Rocket League,
/// this can be used to load custom map files, but on Epic version it only
/// works on the Psyonix maps. Still useful because maintaining the gameMap
/// enum as new Psyonix maps are added is annoying.
func (rcv *MatchSettings) GameMapUpk() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The name of a upk file, like UtopiaStadium_P, which should be loaded.
/// If specified, this overrides gameMap. On Steam version of Rocket League,
/// this can be used to load custom map files, but on Epic version it only
/// works on the Psyonix maps. Still useful because maintaining the gameMap
/// enum as new Psyonix maps are added is annoying.
func MatchSettingsStart(builder *flatbuffers.Builder) {
	builder.StartObject(12)
}
func MatchSettingsAddPlayerConfigurations(builder *flatbuffers.Builder, playerConfigurations flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(playerConfigurations), 0)
}
func MatchSettingsStartPlayerConfigurationsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MatchSettingsAddGameMode(builder *flatbuffers.Builder, gameMode int8) {
	builder.PrependInt8Slot(1, gameMode, 0)
}
func MatchSettingsAddGameMap(builder *flatbuffers.Builder, gameMap int8) {
	builder.PrependInt8Slot(2, gameMap, 0)
}
func MatchSettingsAddSkipReplays(builder *flatbuffers.Builder, skipReplays byte) {
	builder.PrependByteSlot(3, skipReplays, 0)
}
func MatchSettingsAddInstantStart(builder *flatbuffers.Builder, instantStart byte) {
	builder.PrependByteSlot(4, instantStart, 0)
}
func MatchSettingsAddMutatorSettings(builder *flatbuffers.Builder, mutatorSettings flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(mutatorSettings), 0)
}
func MatchSettingsAddExistingMatchBehavior(builder *flatbuffers.Builder, existingMatchBehavior int8) {
	builder.PrependInt8Slot(6, existingMatchBehavior, 0)
}
func MatchSettingsAddEnableLockstep(builder *flatbuffers.Builder, enableLockstep byte) {
	builder.PrependByteSlot(7, enableLockstep, 0)
}
func MatchSettingsAddEnableRendering(builder *flatbuffers.Builder, enableRendering byte) {
	builder.PrependByteSlot(8, enableRendering, 0)
}
func MatchSettingsAddEnableStateSetting(builder *flatbuffers.Builder, enableStateSetting byte) {
	builder.PrependByteSlot(9, enableStateSetting, 0)
}
func MatchSettingsAddAutoSaveReplay(builder *flatbuffers.Builder, autoSaveReplay byte) {
	builder.PrependByteSlot(10, autoSaveReplay, 0)
}
func MatchSettingsAddGameMapUpk(builder *flatbuffers.Builder, gameMapUpk flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(gameMapUpk), 0)
}
func MatchSettingsEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
